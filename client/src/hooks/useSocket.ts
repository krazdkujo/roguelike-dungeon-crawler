import { useEffect, useState, useCallback, useRef } from 'react';\nimport { useAppSelector } from '@/stores/hooks';\nimport { socketService } from '@/services/socketService';\n\nexport interface SocketState {\n  connected: boolean;\n  connecting: boolean;\n  error: string | null;\n  latency: number;\n}\n\nexport const useSocket = () => {\n  const { tokens } = useAppSelector(state => state.auth);\n  const [socketState, setSocketState] = useState<SocketState>({\n    connected: false,\n    connecting: false,\n    error: null,\n    latency: 0\n  });\n  \n  const latencyIntervalRef = useRef<NodeJS.Timeout | null>(null);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  // Initialize socket connection\n  useEffect(() => {\n    if (!tokens?.accessToken) {\n      // No token, disconnect if connected\n      if (socketService.isConnected()) {\n        socketService.disconnect();\n        setSocketState({\n          connected: false,\n          connecting: false,\n          error: null,\n          latency: 0\n        });\n      }\n      return;\n    }\n\n    // Connect with token\n    const connectSocket = async () => {\n      if (socketService.isConnected()) {\n        setSocketState(prev => ({ ...prev, connected: true, connecting: false }));\n        return;\n      }\n\n      setSocketState(prev => ({ ...prev, connecting: true, error: null }));\n      \n      try {\n        await socketService.connect(tokens.accessToken);\n        setSocketState({\n          connected: true,\n          connecting: false,\n          error: null,\n          latency: 0\n        });\n        \n        // Start latency monitoring\n        startLatencyMonitoring();\n        \n      } catch (error: any) {\n        setSocketState({\n          connected: false,\n          connecting: false,\n          error: error.message || 'Connection failed',\n          latency: 0\n        });\n        \n        // Retry connection after delay\n        reconnectTimeoutRef.current = setTimeout(() => {\n          if (tokens.accessToken) {\n            connectSocket();\n          }\n        }, 5000);\n      }\n    };\n\n    connectSocket();\n\n    // Cleanup function\n    return () => {\n      if (latencyIntervalRef.current) {\n        clearInterval(latencyIntervalRef.current);\n        latencyIntervalRef.current = null;\n      }\n      if (reconnectTimeoutRef.current) {\n        clearTimeout(reconnectTimeoutRef.current);\n        reconnectTimeoutRef.current = null;\n      }\n    };\n  }, [tokens?.accessToken]);\n\n  const startLatencyMonitoring = useCallback(() => {\n    if (latencyIntervalRef.current) {\n      clearInterval(latencyIntervalRef.current);\n    }\n    \n    latencyIntervalRef.current = setInterval(async () => {\n      if (socketService.isConnected()) {\n        const latency = await socketService.ping();\n        if (latency >= 0) {\n          setSocketState(prev => ({ ...prev, latency }));\n        } else {\n          // Connection lost\n          setSocketState(prev => ({\n            ...prev,\n            connected: false,\n            latency: 0,\n            error: 'Connection lost'\n          }));\n        }\n      }\n    }, 30000); // Check every 30 seconds\n  }, []);\n\n  // Socket event handlers\n  const on = useCallback((event: string, callback: (data: any) => void) => {\n    socketService.on(event, callback);\n    \n    // Return cleanup function\n    return () => {\n      socketService.off(event, callback);\n    };\n  }, []);\n\n  const emit = useCallback((event: string, data?: any) => {\n    if (socketService.isConnected()) {\n      socketService.emit(event, data);\n    } else {\n      console.warn('Cannot emit event: Socket not connected');\n    }\n  }, []);\n\n  // Combat methods\n  const combat = {\n    join: useCallback((combatId: string) => {\n      socketService.joinCombat(combatId);\n    }, []),\n    \n    leave: useCallback((combatId: string) => {\n      socketService.leaveCombat(combatId);\n    }, []),\n    \n    executeAction: useCallback((combatId: string, actionId: string, targetId?: string) => {\n      socketService.executeAction(combatId, actionId, targetId);\n    }, [])\n  };\n\n  // Dungeon methods\n  const dungeon = {\n    join: useCallback((dungeonId: string) => {\n      socketService.joinDungeon(dungeonId);\n    }, []),\n    \n    leave: useCallback((dungeonId: string) => {\n      socketService.leaveDungeon(dungeonId);\n    }, []),\n    \n    action: useCallback((dungeonId: string, action: string, data?: any) => {\n      socketService.dungeonAction(dungeonId, action, data);\n    }, [])\n  };\n\n  // Chat methods\n  const chat = {\n    send: useCallback((channel: string, message: string) => {\n      socketService.sendChatMessage(channel, message);\n    }, []),\n    \n    join: useCallback((channel: string) => {\n      socketService.joinChatChannel(channel);\n    }, []),\n    \n    leave: useCallback((channel: string) => {\n      socketService.leaveChatChannel(channel);\n    }, [])\n  };\n\n  // Manual reconnection\n  const reconnect = useCallback(async () => {\n    if (!tokens?.accessToken) {\n      console.warn('Cannot reconnect: No access token');\n      return;\n    }\n\n    setSocketState(prev => ({ ...prev, connecting: true, error: null }));\n    \n    try {\n      socketService.disconnect();\n      await socketService.connect(tokens.accessToken);\n      \n      setSocketState({\n        connected: true,\n        connecting: false,\n        error: null,\n        latency: 0\n      });\n      \n      startLatencyMonitoring();\n      \n    } catch (error: any) {\n      setSocketState({\n        connected: false,\n        connecting: false,\n        error: error.message || 'Reconnection failed',\n        latency: 0\n      });\n    }\n  }, [tokens?.accessToken, startLatencyMonitoring]);\n\n  // Disconnect method\n  const disconnect = useCallback(() => {\n    socketService.disconnect();\n    setSocketState({\n      connected: false,\n      connecting: false,\n      error: null,\n      latency: 0\n    });\n    \n    if (latencyIntervalRef.current) {\n      clearInterval(latencyIntervalRef.current);\n      latencyIntervalRef.current = null;\n    }\n  }, []);\n\n  return {\n    ...socketState,\n    on,\n    emit,\n    combat,\n    dungeon,\n    chat,\n    reconnect,\n    disconnect\n  };\n};\n\n// Specialized hooks for specific features\nexport const useCombatSocket = (combatId?: string) => {\n  const socket = useSocket();\n  const [combatData, setCombatData] = useState<any>(null);\n  const [actionInProgress, setActionInProgress] = useState(false);\n\n  useEffect(() => {\n    if (!socket.connected || !combatId) return;\n\n    socket.combat.join(combatId);\n\n    const cleanupCallbacks = [\n      socket.on('combat:turn', (data) => {\n        setCombatData(prev => ({ ...prev, ...data }));\n        setActionInProgress(false);\n      }),\n      \n      socket.on('combat:action', (data) => {\n        setCombatData(prev => ({ ...prev, lastAction: data }));\n      }),\n      \n      socket.on('combat:end', (data) => {\n        setCombatData(prev => ({ ...prev, result: data }));\n        setActionInProgress(false);\n      })\n    ];\n\n    return () => {\n      socket.combat.leave(combatId);\n      cleanupCallbacks.forEach(cleanup => cleanup());\n    };\n  }, [socket.connected, combatId]);\n\n  const executeAction = useCallback((actionId: string, targetId?: string) => {\n    if (combatId && socket.connected && !actionInProgress) {\n      setActionInProgress(true);\n      socket.combat.executeAction(combatId, actionId, targetId);\n    }\n  }, [combatId, socket, actionInProgress]);\n\n  return {\n    ...socket,\n    combatData,\n    actionInProgress,\n    executeAction\n  };\n};\n\nexport const useDungeonSocket = (dungeonId?: string) => {\n  const socket = useSocket();\n  const [dungeonData, setDungeonData] = useState<any>(null);\n\n  useEffect(() => {\n    if (!socket.connected || !dungeonId) return;\n\n    socket.dungeon.join(dungeonId);\n\n    const cleanupCallbacks = [\n      socket.on('dungeon:progress', (data) => {\n        setDungeonData(prev => ({ ...prev, ...data }));\n      }),\n      \n      socket.on('dungeon:complete', (data) => {\n        setDungeonData(prev => ({ ...prev, completed: true, result: data }));\n      })\n    ];\n\n    return () => {\n      socket.dungeon.leave(dungeonId);\n      cleanupCallbacks.forEach(cleanup => cleanup());\n    };\n  }, [socket.connected, dungeonId]);\n\n  return {\n    ...socket,\n    dungeonData\n  };\n};\n\nexport const useChatSocket = (channel: string = 'global') => {\n  const socket = useSocket();\n  const [messages, setMessages] = useState<any[]>([]);\n\n  useEffect(() => {\n    if (!socket.connected) return;\n\n    socket.chat.join(channel);\n\n    const cleanup = socket.on('chat:message', (data) => {\n      if (data.channel === channel) {\n        setMessages(prev => [...prev.slice(-49), data]); // Keep last 50 messages\n      }\n    });\n\n    return () => {\n      socket.chat.leave(channel);\n      cleanup();\n    };\n  }, [socket.connected, channel]);\n\n  const sendMessage = useCallback((message: string) => {\n    socket.chat.send(channel, message);\n  }, [socket, channel]);\n\n  return {\n    ...socket,\n    messages,\n    sendMessage\n  };\n};"