import { io, Socket } from 'socket.io-client';\nimport { store } from '@/stores/store';\n\nclass SocketService {\n  private socket: Socket | null = null;\n  private isConnecting = false;\n\n  connect(token: string): Promise<Socket> {\n    return new Promise((resolve, reject) => {\n      if (this.socket?.connected) {\n        resolve(this.socket);\n        return;\n      }\n\n      if (this.isConnecting) {\n        // If already connecting, wait for the current connection attempt\n        const checkConnection = () => {\n          if (this.socket?.connected) {\n            resolve(this.socket);\n          } else {\n            setTimeout(checkConnection, 100);\n          }\n        };\n        checkConnection();\n        return;\n      }\n\n      this.isConnecting = true;\n      \n      // Use environment variable or default to localhost\n      const serverUrl = process.env.VITE_API_URL || 'http://localhost:3001';\n      \n      this.socket = io(serverUrl, {\n        auth: {\n          token\n        },\n        transports: ['websocket', 'polling'],\n        reconnection: true,\n        reconnectionAttempts: 5,\n        reconnectionDelay: 1000,\n        timeout: 20000\n      });\n\n      this.socket.on('connect', () => {\n        console.log('✅ Socket.io connected:', this.socket?.id);\n        this.isConnecting = false;\n        this.setupEventListeners();\n        resolve(this.socket!);\n      });\n\n      this.socket.on('connect_error', (error) => {\n        console.error('❌ Socket.io connection error:', error);\n        this.isConnecting = false;\n        reject(error);\n      });\n\n      this.socket.on('disconnect', (reason) => {\n        console.warn('🔌 Socket.io disconnected:', reason);\n        this.isConnecting = false;\n      });\n\n      this.socket.on('reconnect', (attemptNumber) => {\n        console.log('🔄 Socket.io reconnected after', attemptNumber, 'attempts');\n        this.setupEventListeners();\n      });\n\n      this.socket.on('reconnect_error', (error) => {\n        console.error('🔄❌ Socket.io reconnection error:', error);\n      });\n    });\n  }\n\n  private setupEventListeners(): void {\n    if (!this.socket) return;\n\n    // Combat events\n    this.socket.on('combat:turn', (data) => {\n      console.log('🎮 Combat turn event:', data);\n      // Dispatch to Redux store\n      store.dispatch({ type: 'combat/updateTurn', payload: data });\n    });\n\n    this.socket.on('combat:action', (data) => {\n      console.log('⚔️ Combat action event:', data);\n      store.dispatch({ type: 'combat/actionExecuted', payload: data });\n    });\n\n    this.socket.on('combat:damage', (data) => {\n      console.log('💥 Combat damage event:', data);\n      store.dispatch({ type: 'combat/damageDealt', payload: data });\n    });\n\n    this.socket.on('combat:end', (data) => {\n      console.log('🏁 Combat end event:', data);\n      store.dispatch({ type: 'combat/combatEnded', payload: data });\n    });\n\n    // Dungeon events\n    this.socket.on('dungeon:entered', (data) => {\n      console.log('🚪 Dungeon entered:', data);\n      store.dispatch({ type: 'game/dungeonEntered', payload: data });\n    });\n\n    this.socket.on('dungeon:progress', (data) => {\n      console.log('🏃 Dungeon progress:', data);\n      store.dispatch({ type: 'game/dungeonProgress', payload: data });\n    });\n\n    this.socket.on('dungeon:complete', (data) => {\n      console.log('🎉 Dungeon completed:', data);\n      store.dispatch({ type: 'game/dungeonCompleted', payload: data });\n    });\n\n    // Player events\n    this.socket.on('player:stats_updated', (data) => {\n      console.log('📊 Player stats updated:', data);\n      store.dispatch({ type: 'auth/updatePlayerStats', payload: data });\n    });\n\n    this.socket.on('player:level_up', (data) => {\n      console.log('⭐ Player leveled up:', data);\n      store.dispatch({ type: 'auth/playerLevelUp', payload: data });\n    });\n\n    // Chat/Social events\n    this.socket.on('chat:message', (data) => {\n      console.log('💬 Chat message:', data);\n      store.dispatch({ type: 'ui/addChatMessage', payload: data });\n    });\n\n    this.socket.on('player:online', (data) => {\n      console.log('🟢 Player online:', data);\n      store.dispatch({ type: 'ui/playerOnline', payload: data });\n    });\n\n    this.socket.on('player:offline', (data) => {\n      console.log('🔴 Player offline:', data);\n      store.dispatch({ type: 'ui/playerOffline', payload: data });\n    });\n\n    // Error handling\n    this.socket.on('error', (error) => {\n      console.error('🚨 Socket error:', error);\n      store.dispatch({ type: 'ui/addNotification', payload: {\n        type: 'error',\n        message: error.message || 'Socket connection error',\n        timestamp: Date.now()\n      }});\n    });\n  }\n\n  disconnect(): void {\n    if (this.socket) {\n      console.log('🔌 Disconnecting socket...');\n      this.socket.disconnect();\n      this.socket = null;\n    }\n  }\n\n  // Combat-related methods\n  joinCombat(combatId: string): void {\n    this.socket?.emit('combat:join', { combatId });\n  }\n\n  leaveCombat(combatId: string): void {\n    this.socket?.emit('combat:leave', { combatId });\n  }\n\n  executeAction(combatId: string, actionId: string, targetId?: string): void {\n    this.socket?.emit('combat:action', {\n      combatId,\n      actionId,\n      targetId\n    });\n  }\n\n  // Dungeon-related methods\n  joinDungeon(dungeonId: string): void {\n    this.socket?.emit('dungeon:join', { dungeonId });\n  }\n\n  leaveDungeon(dungeonId: string): void {\n    this.socket?.emit('dungeon:leave', { dungeonId });\n  }\n\n  dungeonAction(dungeonId: string, action: string, data?: any): void {\n    this.socket?.emit('dungeon:action', {\n      dungeonId,\n      action,\n      data\n    });\n  }\n\n  // Chat methods\n  sendChatMessage(channel: string, message: string): void {\n    this.socket?.emit('chat:send', {\n      channel,\n      message,\n      timestamp: Date.now()\n    });\n  }\n\n  joinChatChannel(channel: string): void {\n    this.socket?.emit('chat:join', { channel });\n  }\n\n  leaveChatChannel(channel: string): void {\n    this.socket?.emit('chat:leave', { channel });\n  }\n\n  // Utility methods\n  isConnected(): boolean {\n    return this.socket?.connected || false;\n  }\n\n  getSocketId(): string | undefined {\n    return this.socket?.id;\n  }\n\n  emit(event: string, data?: any): void {\n    this.socket?.emit(event, data);\n  }\n\n  on(event: string, callback: (data: any) => void): void {\n    this.socket?.on(event, callback);\n  }\n\n  off(event: string, callback?: (data: any) => void): void {\n    this.socket?.off(event, callback);\n  }\n\n  // Health check method\n  ping(): Promise<number> {\n    return new Promise((resolve) => {\n      if (!this.socket?.connected) {\n        resolve(-1);\n        return;\n      }\n\n      const start = Date.now();\n      \n      this.socket.emit('ping', { timestamp: start });\n      \n      this.socket.once('pong', (data) => {\n        const latency = Date.now() - data.timestamp;\n        resolve(latency);\n      });\n      \n      // Timeout after 5 seconds\n      setTimeout(() => resolve(-1), 5000);\n    });\n  }\n}\n\nexport const socketService = new SocketService();"